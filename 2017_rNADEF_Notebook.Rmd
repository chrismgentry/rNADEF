---
title: "rNADEF Workbook"
author: North American Dendroecological Fieldweek <br> <i><small>Stockton Maxwell,
  Grant Harley, Chris Gentry, and data from many others</small></i> <br>
output:
  html_notebook: 
    number_sections: yes
    theme: readable
    toc: yes
  html_document:
    df_print: paged
    rows.print: 10
  pdf_document: default
editor_options: 
  chunk_output_type: inline
---
<style>
  .col2 {
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }
  .col3 {
    columns: 3 100px;
    -webkit-columns: 3 100px;
    -moz-columns: 3 100px;
  }
</style>

# Packages used in this Document<br>
There are a number of useful packages for manipulating and analyzing data in **R**. In this document we will use a few of the primary packages specific to tree-ring analysis.</br> 
<div class="col2">
<ul>
+ dplR
+ treeclim
+ graphics
+ utils
+ TRADER
+ burnr
+ ggplot2
</ul></div><br>
If you do not have one or many of these packages installed you can add them by using ```install.packages(x)``` function where *x* is the name of the package you desire to install. Start by loading all of the packages:</br>

```{r Packages, message=FALSE, paged.print=FALSE}
library(dplR)
library(treeclim)
library(graphics)
library(utils)
library(TRADER)
library(burnr)
library(ggplot2)
```

# COFECHA in dplR
Using the script below, you will be able to read in raw ring width files for *COFECHA*-like analysis. To run your own data, change the ```fname```  to match the data in your ```data <- read.rwl(fname = ... , format = "auto")``` script. You can also examine summary statistics of your ring width file using the ```rwl.stats(x)``` function. Alternatively you can use the RWL file included in this project.

```{r Import Data and Analyze, echo=TRUE}
grow.rwl <- read.rwl(fname = "wa091.rwl", format = "auto")
rwl.stats(grow.rwl)
```

You can plot this information to view the time series and/or skeleton plot of a series. To see the time series, use the function ```seg.plot(x)```. To view the skeleton plot of an individual series, use ```skel.plot(x[#])``` where # is the series/core you would like to view.

```{r Plot Time Series, echo=TRUE, fig.height=5, fig.width=10}
seg.plot(grow.rwl)
skel.plot(grow.rwl[1])
```

You can also examine the radii (mm) for each series, common time interval, and mean sensitivity of the rwl. While there isn't a direct function in *dplR* to calculate radii, you can use ```colSums()``` from base R to calculate the values. For the common interval and mean sensitivity you can use ```common.interval()``` and ```sens1()``` respectively.

```{r Radii-ComInt-MeanSen, echo=TRUE, fig.height=10, fig.width=10}
data.frame(colSums(grow.rwl, na.rm = TRUE, dims = 1))
wa091.common <- common.interval(grow.rwl, type=c("years"), make.plot=TRUE)
sens1(grow.rwl)
```

## Crossdating

Using functions from **dplR** you can also obtain a *COFECH*-like output with the ```corr.rwl.seg()``` function. You can also examine an individual series with ```series.rwl.plot()```. Please note that the options used in the examples below are specific to this project and might be different from your specific analysis.

```{r Crossdating, echo=TRUE, results='hide', fig.keep='all', fig.height=10, fig.width=10, message=FALSE, warning=FALSE}
corr.rwl.seg(rwl = grow.rwl, seg.length = 50, bin.floor = 100, n = NULL, prewhiten = TRUE, pcrit = 0.05, 
             biweight = TRUE, method = c("spearman"), make.plot = TRUE, label.cex = 1, floor.plus1 = FALSE,
             master = NULL)
```
To examine an individual series you will need to be able to identify the specific series in the function.
```{r Series Plot, echo=TRUE, results='hide', fig.keep='all', message=FALSE, warning=FALSE, fig.height=10, fig.width=10}
series.rwl.plot(grow.rwl, series = "TCT202A", series.yrs = as.numeric(names(series)),
                seg.length = 50, bin.floor = 100, n = NULL,
                prewhiten = TRUE, biweight = TRUE, floor.plus1 = FALSE)
```

To facilitate crossdating you can also use *dplR* to calculate marker rings with the ```pointer()``` function. 

```{r Marker Rings, echo=TRUE}
markers <- pointer(grow.rwl)
markers
```


## Spaghetti plot of raw ring widths

Frequently you will see a plot of the ring widths of all series on the same graph. These *spaghetti plots* can be created using the ```spag.plot()``` function in **dplR**.
```{r Spag Plot, echo=TRUE, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
spag.plot(rwl = grow.rwl, zfac = 1, useRaster = FALSE, res = 300)
```

# Arstan in dplR

The standalone **ARSTAN** program allows you to develop chronologies and interactively detrend series. These options are also baked into **dplR**. To run interactive detrending you can use the ```i.detrend()``` function.
```{r iDetrending, include=TRUE, message=FALSE, warning=FALSE}
grow.rwi.int <- i.detrend(rwl = grow.rwl, nyrs = NULL, f = 0.5,pos.slope = FALSE) #allows you to see a variety of fits
```
You will need to select a detrending method for each series.

To view the spaghetti plot for the detrended series you can once again use the ```spag.plot()``` function similar to above except substituting the raw ring width data for the detrended data.
```{r Detrend Spag Plot, echo=TRUE, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
spag.plot(rwl = grow.rwi.int, zfac = 1, useRaster = FALSE, res = 300)
```

If you want to utilize a singular detrending method for all of your series you can use the ```detrend()``` function instead of ```i.detrend()```. In this function you will choose one of the following detrending options with *method = *: "Spline", "ModNegExp", "Mean", "Ar", "Friedman", or "ModHugershoff".

```{r Detrending, echo=TRUE, message=FALSE, warning=FALSE}
grow.rwi <- detrend(rwl = grow.rwl, method = c("Spline"), nyrs = NULL, f = 0.5, pos.slope = FALSE)
grow.rwi
```

To examine the statistics for the entire chronology you can use ```rwi.stats()``` or ```rwi.stats.running()``` to use running statistics in order to adjust the time periods.

```{r Stats, echo=TRUE, message=FALSE, warning=FALSE}
rwi.stats(grow.rwi)
```

```{r RunStats, echo=TRUE, message=FALSE, warning=FALSE}
rwi.stats.running(grow.rwi)
```

The ARSTAN program generates a standardized chronology, an ARSTAN chronology, and a residual chronology. In *dplR* you can use the ```chron()``` function to build a mean value chronology from detrended ring widths produced from a ```detrend()``` function. 

Standardized chronology:
```{r Standardized, echo=TRUE, message=FALSE, warning=FALSE}
grow.crn <- chron(x = grow.rwi, prefix = "TAH", biweight = TRUE, prewhiten = FALSE)
grow.crn
```

Standardized and Residual chronologies:
```{r Residual, echo=TRUE, message=FALSE, warning=FALSE}
grow.crn <- chron(x = grow.rwi, prefix = "TAH", biweight = TRUE, prewhiten = TRUE)
grow.crn
```

You can then plot the chronology using ```crn.plot()``` to view chronologies developed with ```chron()```.

```{r ChronPlot, echo=TRUE, fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
crn.plot(crn = grow.crn, add.spline = TRUE, nyrs = NULL, f = 0.5, crn.line.col='grey50',
         spline.line.col='red', samp.depth.col='grey90', samp.depth.border.col='grey80',
         crn.lwd=1, spline.lwd=2.0, abline.pos=1, abline.col='black', abline.lty=1,abline.lwd=1,
         xlab="Time", ylab="RWI")
```

#wavelet transform
Years <- as.numeric(rownames(grow.crn))
PANstd <- grow.crn[, 1]
out.wave <- morlet(y1 = PANstd, x1 = Years, p2 = 9, dj = 0.1,
                   siglvl = 0.99)
wavelet.plot(out.wave, useRaster = NA)

# Treeclim

To begin in **TreeClim** you need to load a chronology. You can use your own chronology or the chronology developed in the previous steps. With the script below, you can view a summary of the chronology you will be using for this analysis. Alternatively, you can change the name of the chronology to one you have generated.
```{r ChronSum, echo=TRUE, message=FALSE, warning=FALSE}
#summary of the chronology
summary(grow.crn)
```

Next you will need to load climate data. There are a number of methods for adding climate data but this example has one as a csv file in the project.

```{r Climate Data, echo=TRUE, message=FALSE, warning=FALSE}
climate <- read.csv("WA_div5_climate_cascades_west.csv", header = TRUE)
names(climate)
summary(climate)
ym <- climate[,1:2] #pull year and month columns
var1 <- climate[3] #pull climate variables, 1 or 2 at a time to avoid N problems
clim <- data.frame(c(ym, var1)) #build climate data frame 
summary(clim)
```


#Response function analysis in treeclim - modeled after Dendroclim2002. 
#Now can take dynamic = "static", "moving", "evolving"
resp <- dcc(chrono = grow.crn, climate = clim, selection = -5:10, 
            method = "response", dynamic = "evolving", win_size = 35, win_offset = 1, start_last = TRUE,
            timespan = NULL, var_names = NULL, ci = 0.05, boot = "std", sb = FALSE)
coef <- coef(resp)
plot(resp)
resp #show model results
traceplot(resp, variables = NULL, facet = FALSE)
#save the output
write.csv(coef, file = ("pcp_coef.csv")) #output coeff
tiff("resp_coef.tiff", width = 8, height = 4, units = 'in', res = 300) #write plot to file
plot.new()
plot(resp)
title(main = "Climate", xlab = "Month")
dev.off()

#evaluate recon skill with split calibration, requires 2 climate variables
recon <- dcc(chrono = grow.crn, climate = clim, selection = 1:2, #use a selection with recon variable of interest
             method = "response", dynamic = "static", win_size = 35, win_offset = 1, start_last = TRUE,
             timespan = NULL, var_names = NULL, ci = 0.05, boot = "std", sb = FALSE)
recon_coef <- coef(recon)
plot(recon)
recon #show model results
#this does the evaluation
skillz <- skills(object = recon, target = .mean(1:2), model = "ols", calibration = "50%", timespan = NULL)
plot(skillz)
skillz #show model results

#evaluate recon skill with split calibration with single variable
recon_dlm <- dlm(chrono = grow.crn, climate = clim, selection = 2, timespan = NULL, var_names = NULL,
                 param_names = NULL, intercept = TRUE, scale = FALSE)
recon_coef <- coef(recon_dlm)
plot(recon_dlm)

recon_dlm #show model results
#this does the evaluation
skillz <- skills(object = recon_dlm, target = 2, model = "ols", calibration = "50%", timespan = NULL)
plot(skillz)
skillz #show model results

#seasonal correlation - try it
climate <- read.csv("WA_div5_climate_cascades_west.csv", header = TRUE)
names(climate)
summary(climate)
ym <- climate[,1:2] #pull year and month columns
var1 <- climate[3:4] #pull climate variables, 1 or 2 at a time to avoid N problems
clim <- data.frame(c(ym, var1)) #build climate data frame 
summary(clim)
seas <- seascorr(grow.crn, climate, var_names = NULL, timespan = NULL, complete = 9,
                 season_lengths = c(1, 3, 6), primary = 1, secondary = 2, ci = 0.05)
plot(seas)
seas

# TRADER Code for Growth Release Detection

**TRADER**, Tree Ring Analysis of Disturbance Events in R, is a package for disturbance reconstruction from tree-ring data. Analyses include Absolute Increase (Fraver & White 2005), Growth Averaging (Nowacki & Abrams 1997), Boundary Line (Black & Abrams 2003), and Splechtna (Splechtna, Gratzer & Black 2005) which combines growth averaging and boundary line techniques. 

To start you need to read in a rwl file to begin the analysis.

```{r Trader Data, echo=TRUE, message=FALSE, warning=FALSE}
thedata <- read.rwl('wa091.rwl')
```

For this example the *Growth Averaging*, ```growthAveragingALL()```, technique will be used with a the following paramenters: years averaged prior to release = 10 (*m1*), years averaged after release = 10, number of years between release events = 10, moderate relase = 0.25, major release = 0.50, with 5yrs of exceeding growth to be considered a release. Note, some of the analyses will create a large number of files to be created in your working directory/

```{r NowackiAbrams, echo=TRUE, message=FALSE, warning=FALSE}
growthAveragingALL(thedata, releases = NULL, m1 = 10, m2 = 10,buffer = 10, drawing = TRUE, criteria = 0.25, criteria2 = 0.50,prefix = "ga", gfun = mean, length = 5, storedev = jpeg)
```

#plot raw data
spag.plot(thedata, zfac = 1, useRaster = FALSE, res = 300)
thedata.raw.crn <- chron(thedata, prefix = "CAM", prewhiten=FALSE)
plot(thedata.raw.crn,abline.pos=NULL,ylab='mm',xlab='Year')

#Basal Area Increment calculation in dplR

grow.rwl <- read.rwl(fname = "wa091.rwl", format = "auto") #just change fname to run stuff below
basal <- bai.out(grow.rwl, diam = NULL)
basal_p <- print(basal)
spag.plot(basal[1], zfac = 1, useRaster = FALSE, res = 300)
write.csv(basal_p, "basal_bai.csv")

# burnR

The **burnR** package creates composite fire history plots similar to the **FHX2** and **FHAES** programs. It uses *FHX* formatted files. An example of a FHX file is included on this project.

After loading the ```burnr``` library, you can use ```read_fhx()``` to load data already formatted into the FHX format.

```{r Load FHX, echo=TRUE, message=FALSE, warning=FALSE}
Zion <- read_fhx('Zion.fhx')
```

Although each of the samples have an ID, we can add so site information in order to facet our plots. This will sort each of the samples into the appropriate category when facted with the ```plot_demograph``` function.

```{r Plot Facet FHX, echo=TRUE, message=FALSE, warning=FALSE}
Sites <- read.csv('ZionSiteIDs.csv')
facetplot <- plot_demograph(Zion, facet_group = Sites$SiteID, facet_id = Sites$series, plot_legend = TRUE)
print(facetplot)
```

Another option available in ```plot_demograph``` is a to create a plot of all samples with a composite plot beneath the plot of individuals. In addition to the plot and composite, you can also add annotations to highlight common fire dates.

```{r Plot Comp FHX, echo=TRUE, message=FALSE, warning=FALSE}
rugplot <- plot_demograph(Zion, composite_rug = TRUE, plot_legend = TRUE)
compositerug <- rugplot + 
  annotate('rect', xmin = 1721, xmax = 1723, ymin = 0, ymax = 21, alpha = 0.4) + 
  annotate('rect', xmin = 1734, xmax = 1736, ymin = 0, ymax = 21, alpha = 0.4) + 
  annotate('rect', xmin = 1748, xmax = 1750, ymin = 0, ymax = 21, alpha = 0.4) + 
  annotate('rect', xmin = 1777, xmax = 1779, ymin = 0, ymax = 21, alpha = 0.4) + 
  annotate('rect', xmin = 1793, xmax = 1795, ymin = 0, ymax = 21, alpha = 0.4) + 
  scale_x_continuous(limits=c(1450, 2005), breaks = seq(1450,2005,25)) + 
  theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust = 0.2), 
        panel.grid.major = element_blank(), panel.grid.minor = element_blank())
print(compositerug)
```

-----------------------------------------------------
This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 
